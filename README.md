
# ad_stat_bot
## src/bot
бот с упоминаниями артикулов в телеграм каналах 
- ### broadcast_message.py
  рассылка новостей бота всем пользователям
- ### keyboards.py  
  переменные кнопок и клавиатур
- ### launcher.py
  точка входа для бота
- ### message_handler.py  
  обработчик сообщений
    * send_message_with_limit - метод для отправки сообщения с лимитом в 4096 символов, отправляет длинное сообщение
        в виде нескольких, разделение на подсообщения по символу новой строки, для поиска символа новой строки используется метод find_index_of_nearest_newline()
    * find_index_of_nearest_newline - ищет символ новой строки, от end_index и к началу текста  
  <a/>
  остальные методы для обработки сообщений и формирования текстовых ответов
- ### user_states.py  
  класс для состояний бота
## src/dao
здесь все orm модельки и методы
- ### db_config.py  
  класс-обертка для того, чтобы удобно делать строку-подключение, которая передается при создании движка SQLAlchemy
- ### proxy.py  
  ORM для таблички top_blogger_stat_bot.proxies, get_http_dict - этот словарик для библиотеки requests, get_http_config_dict - словарик для библиоткеи telethon
- ### mentions_db.py  
  ORM модельки для всех таблиц схемы mentions
    * классы Chat, Post, SkuPerPost, Brand, ChatContentType, Sku - orm модельки таблиц [схемы](https://dbdiagram.io/d/parser_result_post-6508a60c02bd1c4a5ece5ba9) 
    * Proxy - orm модель для таблички mentions.proxies
       - get_http_dict - словарик для библиотеки requests
       - get_http_config_dict - словарик для библиоткеи telethon
    * MentionsDatabase.upload_wb_items_ad_parser_results - загружает результаты парсера TgWbItemsAdChatParser.Result
    * .upload_chat_ad_parser_results - загружает результаты парсера TgChatAdChatParser.Result
    * .update_tg_chat - обновляет чат в табличке Chat, в поле updated_at ставит datetime.now()
    * .update_tg_chat_without_update_time - обновляет чат в табличке Chat, поле updated_at не меняет
    * .upload_chats_to_db - загружает чаты в табличку chat, проверяет не было ли уже загружено чатов с такими tg_id/link
    * .upload_tg_posts_to_db - загружает посты в табличку, типы: parsed_posts: set[Chat], parsed_skus: dict[int, Sku]
            сначала делается запрос к wb_api для того, чтобы 1) удостовериться, что артикулы валидны, 2) получить brand_id для каждого артикула  
            вызываем .load_sku, он делает проверку есть ли уже такой sku в нашей бд, и валиден ли артикул вообще, если артикул не валиден, то вызывается .clean_sku_post, который удаляет orm relationship'ы, чтобы случайно не загрузилось то, чего не надо, когда все артикулы загружены, то загружаются посты, а вместе с ними и SkuPerPost, перед загрузкой постов также делается проверка, есть ли уже такая запись с таким post.chat_id & post.message_id
- ### users_db.py  
  orm модельки для [схемы](https://dbdiagram.io/d/655e42793be1495787890692)
    * UserDatabase.check_user - проверяет есть ли юзер в таблице user, добавляет юзера, если его еще нет
    * UserDatabase.add_new_user_request - добавляет в таблицу user_request запись о запросе
    * UserDatabase.update_user_last_interaction - обновляет поле last_interaction_date в табличке user для пользователя
## src/parsers/tg
Парсеры телеграма, библиотека telethon, opentele (обертка над telethon для компроментации api нашего клинета телеграм (как будто наши запросы библиотеки telethon идут от official apps.   PS According to [Telegram TOS](https://core.telegram.org/api/obtaining_api_id#using-the-api-id ): all accounts that sign up or log in using unofficial Telegram API clients are automatically put under observation to avoid violations of the Terms of Servic))
- ### parser_launcher.py  
  запускает парсеры телеграма в потоках, один аккаунт - один поток, на все аккаунты берется одна прокся из таблицы mentions.proxies
  добавляет логгер в корень проекта в папку logs/ParserLauncher/datetime.now()/log.txt  
      
  есть табличка chat, в которой у каждого чата есть chat_content (enum), в зависимости от того, какой парсер будем запускать, мы запрашиваем необходимые чаты. далее все чаты разбиваются на чанки: чаты которые имеют session_id (что означает, что мы вступили в этот чат в такой то сессии (с такого-то аккаунта)) образуют отдельный чанк, чаты которые не имеют session_id распеределяются по образованным чанкам равномерно. дальше мы запускаем N потоков с парсерами, где N - кол-во имеющихся аккаунтов-сессий.  
   
  по завершении парсинга, со всех парсеров собирается результаты, они объединяются и загружаются в бд функцией-загрузчиком
- ### abstract.py  
  абстрактный парсер телеграм каналов  

  парсер сначала должен получить объект канала: те каналы, у которых есть tg_id (это те в которые мы уже вступили) берутся из кеша, для остальных делается запрос на вступление (tg_utils.py.send_join_request), если запрос был тут же одобрен и мы поимели объект чата, то обновляется мы делаем запрос на полную инфу о чате (чтобы понять сколько там подпещиков) и обновляем запись чата в бд (ставим tg_id, session_id, followers).  
  
  потом парсер беребирает сообщения в чате и вызывает метод parse_message(), который возвращает набор распарсенных объектов, которые добавляются в parser.parsed_items. этот метод в абстрактном парсере не определен и переопределеятся в конкретном парсере.
- ### chat.py
  парсер каналов с рекламой других каналов

  наследуется от AbstractTgChatParser
    
  в методе parse_message перебирает гиперссылки и смотрит, если они подходят под регекс тг ссылки.  
  потом ищет ссылки непосредственно в тексте сообщения и ищет упоминания (@канал).  

  для каждой полученной ссылки после делается гет запрос, чтобы получить название канала и кол-во подпещиков (в теории можно и не делать запрос на полную инфу о чате, тк кол-во подпещиков мы в можем узнать, сделав get-запрос по ссылке (как в браузере) и лучше этот запрос на полную инфу не делать), если в названии канала есть 'отзыв' то такую ссылку мы отбрасываем.  

  из неотброшенных ссылок создаются скалкеми объекты для таблички chat с типом wb_items_ads, названием, ссылкой на канал и числом подпещиков.
  
- ### sku.py
  парсер каналов с упоминаниями артикулов

  наследуется от TgChatAdChatParser (чтобы парсить сразу и упоминания артикулов и рекламу других каналов)
  
  в методе parse_message перебирает гиперссылки, делает гет запрос, если ссылка не ведет напрямую на вб (https://vvildberriess.mobz.click/kypalnikbas) и после переадресаций у нас есть вб ссылка из которой мы достаем sku.  
  потом он ищет sku в непосредственно тексте, а потом убирает из полученных ску всякую шляпу по регексу (?<=size=)\d+ (чтобы убрать лишние числа, напр. 238253570 как в ссылке wildberries.ru/catalog/140535829/detail.aspx?targetUrl=BP&size=238253570).  
  
  Если len(sku) != 0 то мы создаем скалкеми объект поста, в который запихиваем message_id, chat_id (чтобы потом формировать линку на пост в формате f't.me/c/{message.chat.id}/{message.id}' она будет работать как для публичных чатов, так и для частных (если пользователь в нем состоит)), для каждого ску создаются скалкеми объекты sku_per_post и сам sku, которые тоже пихаем в объект поста.
- ### utils.py  
  утилы для библиотеки telethon и парсеров телеграма
    * .send_join_requests - посылает запросы в телеграм чаты, в которые мы еще не вступили, в зависимости от типа ссылки (пригласительная (t.me/+xzstElBg19QyMTgy) или публичная (t.me/username))делается нужный запрос
    * .send_join_request - делает один запрос, достается чат из ответа на запрос
    * .get_chat_from_result - достается чат из результата запроса на вступление (если нас автоматически приняли или чат был публичным и мы в него сразу вступили)
    * .get_chat_info_by_link - делается запрос html страницы типа https://t.me/joinchat/xzstElBg19QyMTgy (открывать в браузере) из которой достается title канала/чата и кол-во подписчеков, если ссылка вела на юзера, то вернется (None, None)
## src/parsers/tgstat
Парсеры для сайта tgstat.ru
- ### category.py  
  парсер категории сайта tgstat.

  достает первые chat_limit телеграм каналов со страниц по типу (https://tgstat.ru/design), в том числе и по кнопке "Показать больше"
- ### chat.py  
  парсер чата на tgstat.ru (напр. https://tgstat.ru/channel/@premium).  

  проходится по постам на странице, прожимает кнопку "Показать больше" до тех пока не дойдет до поста с start_date или поста с айдишнеком, который мы уже парсили (mentions.chat.recent_parsed_post_tg_id в бд)  
  
  логика парсинга отдельного поста такая же как и в tg_wb_items_ad_chat_parser.py, грузит спарсенные упоминания сразу, не дожидаясь окончания парсинга всего канала полностью
- ### utils.py  
  всякие утилы, чтобы доставать нужные штуки из html элементов библиотеки bs4
## src/utils
- ### utils.py
    * .format_message_to_print - форматирует сообщение для печати логером
    * .resolve_redirection_link - достает артикул из ссылки (с учетом переадресации)
    * .divide_into_chunks - разбивает входной лист на N листов (чанков)
    * .split_joined_non_joined_chats - разбивает чаты (orm объекты mentions_db.py.Chat) в зависимости от значения поля session_id, те у кого session_id != None, те идут в соответсвующий список в словарике joined_tg_chats, все остальные в список non_joined_tg_chats
    * .add_log_to_file_for_process - добавляет логирование в файл для процесса
- ### wb_utils.py  
  штука чтобы слать запросы WB API (и не только)
    * .get_products - запрос к WB API для получения инфы по списку артикулов
    * .get_brands_by_skus - получение инфы о брендах для списка артикулов, возвращает словарик dict[sku(вроде интом но не факт), BrandRec]
    * .get_names_by_sku - получение инфы о названиях товаров для списка артикулов, возвращает словарик dict[sku(вроде интом но не факт), str]
    * BrandRec - класс-хранилка для бренда
### config.py
* ROOT_DIR - переменная с путем к корню проекта
* LOGGER_LEVEL - уровень логирования
* LOG_FILES_FOLDER - путь к папке с логами
* *_LOGGER_FORMAT - форматирование вывода логера
* SESSIONS_FILE_PATH - путь к папке с сессиями телеграм аккаунтов для парсеров телеграма
* API_IDS - айдишки для telethon'a  
* API_HASHES - хэши для телетона
